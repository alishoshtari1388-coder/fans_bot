

import asyncio
import logging
import zipfile
import re
from io import BytesIO
from datetime import datetime, timedelta
from collections import Counter

from telethon import TelegramClient, events, functions, types
from telethon.tl.types import (
    KeyboardButtonCallback,
    UserStatusOnline,
    UserStatusOffline,
    MessageEntityMentionName,
    MessageActionChatAddUser,
    MessageActionChatDeleteUser
)
from telethon.tl.types import (
    InputBotInlineResult,
    InputBotInlineMessageText
)
from telethon.errors import FloodWaitError
from gtts import gTTS

logging.basicConfig(level=logging.WARNING)
print("Ø®Ø¯Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ± Ø´Ø®ØµÛŒ â€” Ù†Ø³Ø®Ù‡Ù” Ù†Ù‡Ø§ÛŒÛŒ Ú©Ø§Ù…Ù„ â€” Ø¯Ø± Ø­Ø§Ù„ Ø¨ÛŒØ¯Ø§Ø± Ø´Ø¯Ù†...")

# ================== ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ù‡Ù… ==================
API_ID = 26330588  # Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†ÛŒØ¯
API_HASH = "fb26ef0a6a40c89fa8b9d8cd2603b533"  # Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†ÛŒØ¯
BOT_TOKEN = "8568412721:AAHOG5Vn3GlNofmVi4D0hYTPCAumrohxxXg"
ALLOWED_USERS = [5410416130, 8114452804]
ALERT_CHAT_ID = -5000071115
ADMIN_ID = 5410416130
MAX_RESULTS = 800
# ================================================

client = TelegramClient(
    'ultimate_god_mode_final', 
    API_ID, 
    API_HASH,
    connection_retries=5,
    retry_delay=3,
    timeout=60
).start(bot_token=BOT_TOKEN)

# Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
live_targets = {}
watching_alert = set()
watching_online = set()
saved_users = {}
last_profile = {}
last_online_notif = {}
edited_cache = {}
deleted_cache = {}

async def get_user_by_input(user_input):
    """ØªØ§Ø¨Ø¹ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„Ù ÙˆØ±ÙˆØ¯ÛŒ"""
    try:
        # Ø§Ú¯Ø± @ Ø¯Ø§Ø±Ø¯ØŒ Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†
        if user_input.startswith('@'):
            return await client.get_entity(user_input)
        
        # Ø§Ú¯Ø± Ø¹Ø¯Ø¯ Ø§Ø³ØªØŒ Ø³Ø¹ÛŒ Ú©Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø¢ÛŒØ¯ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒ
        if user_input.isdigit():
            user_id = int(user_input)
            
            # Ø±ÙˆØ´ Û±: Ø³Ø¹ÛŒ Ú©Ù† Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§ Ø¢ÛŒØ¯ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ù†ÛŒ
            try:
                return await client.get_entity(user_id)
            except:
                pass
            
            # Ø±ÙˆØ´ Û²: Ø¯Ø± Ø¯ÛŒØ§Ù„ÙˆÚ¯â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ± Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†
            try:
                async for dialog in client.iter_dialogs(limit=100):
                    if dialog.entity.id == user_id:
                        return dialog.entity
            except:
                pass
            
            # Ø±ÙˆØ´ Û³: Ø¯Ø± Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ± Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†
            try:
                async for message in client.iter_messages(None, limit=100):
                    if message.sender and message.sender.id == user_id:
                        return message.sender
            except:
                pass
            
            # Ø§Ú¯Ø± Ù‡ÛŒÚ†Ú©Ø¯Ø§Ù… Ø¬ÙˆØ§Ø¨ Ù†Ø¯Ø§Ø¯ØŒ Ø®Ø·Ø§ Ø¨Ø¯Ù‡
            raise ValueError(f"Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø¢ÛŒØ¯ÛŒ {user_id} Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯. Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø±Ø¨Ø§Øª Ø¹Ø¶Ùˆ Ø§Ø³Øª.")
        
        # Ø§Ú¯Ø± Ù†Ù‡ Ø¹Ø¯Ø¯ Ø§Ø³Øª Ù†Ù‡ @ØŒ Ø³Ø¹ÛŒ Ú©Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† @ Ø¯Ø± Ù†Ø¸Ø± Ø¨Ú¯ÛŒØ±
        return await client.get_entity(f"@{user_input}")
        
    except Exception as e:
        raise ValueError(f"Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø± Ù†Ø§Ù…ÙˆÙÙ‚: {str(e)}")

async def get_user_info(uid):
    """ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±"""
    try:
        user = await client.get_entity(uid)
        return user.username or user.first_name or str(uid)
    except:
        return str(uid)

async def search_today(user_id):
    msgs = []
    try:
        async for m in client.iter_messages(None, from_user=user_id, limit=MAX_RESULTS, wait_time=2):
            if m.date.date() == datetime.now().date():
                msgs.append(m)
                deleted_cache[m.id] = m.text or "[Ù…Ø¯ÛŒØ§]"
                edited_cache[m.id] = m.text or "[Ù…Ø¯ÛŒØ§]"
    except Exception as e:
        print(f"Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ø§Ù…Ø±ÙˆØ²: {e}")
    return msgs

async def search_7days(user_id):
    msgs = []
    cutoff = datetime.now() - timedelta(days=7)
    try:
        async for m in client.iter_messages(None, from_user=user_id, limit=MAX_RESULTS*2):
            if m.date >= cutoff:
                msgs.append(m)
    except:
        pass
    return msgs

async def send_alert(user, message, alert_type="Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯", extra=""):
    try:
        chat = message.chat
        title = getattr(chat, 'title', 'Ú©Ø§Ù…Ù†Øª Ú©Ø§Ù†Ø§Ù„')
        
        if str(chat.id).startswith('-100'):
            link = f"https://t.me/c/{str(chat.id)[4:]}/{message.id}"
        else:
            username = getattr(chat, 'username', '')
            link = f"https://t.me/{username}/{message.id}" if username else "Ù„ÛŒÙ†Ú© Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª"
        
        username_info = await get_user_info(user.id)
        text = f"{alert_type}\n\n@{username_info}\n{title}\n{message.text or '[Ù…Ø¯ÛŒØ§]'}\n{link}\n{extra}"
        await client.send_message(ALERT_CHAT_ID, text)
        
        if message.media:
            await client.send_file(ALERT_CHAT_ID, message.media, caption=f"{alert_type} Ø§Ø² @{username_info}")
    except Exception as e:
        print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø±: {e}")

async def daily_report_task():
    while True:
        now = datetime.now()
        if now.hour == 8 and now.minute < 5:
            for uid, data in saved_users.items():
                await send_daily_report(uid, data['chat_id'])
            await asyncio.sleep(300)
        await asyncio.sleep(60)

async def send_daily_report(user_id, chat_id):
    try:
        user = await client.get_entity(user_id)
        msgs = await search_today(user_id)
        if not msgs:
            return
        
        first = min(msgs, key=lambda x: x.date)
        last = max(msgs, key=lambda x: x.date)
        all_text = " ".join([m.text or "" for m in msgs if m.text])
        words = re.findall(r'\w+', all_text.lower())
        top_words = Counter(words).most_common(10)
        top_str = ", ".join([f"{w}({c})" for w, c in top_words]) if top_words else "Ù†Ø¯Ø§Ø±Ø¯"

        text = f"Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ @{user.username or user_id}\n\n"
        text += f"Ù¾ÛŒØ§Ù… Ø§Ù…Ø±ÙˆØ²: {len(msgs)}\n"
        text += f"Ø§ÙˆÙ„ÛŒÙ† Ù¾ÛŒØ§Ù…: {first.date.strftime('%H:%M')}\n"
        text += f"Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒØ§Ù…: {last.date.strftime('%H:%M')}\n"
        text += f"Ú©Ù„Ù…Ø§Øª Ù¾Ø±ØªÚ©Ø±Ø§Ø±: {top_str}"

        try:
            tts = gTTS(text, lang='fa')
            buf = BytesIO()
            tts.write_to_fp(buf)
            buf.seek(0)
            await client.send_file(chat_id, buf, voice_note=True, caption="Ú¯Ø²Ø§Ø±Ø´ ØµÙˆØªÛŒ Ø®Ø¯Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ±")
        except:
            pass
        
        await client.send_message(chat_id, text)
    except Exception as e:
        print(f"Ø®Ø·Ø§ Ø¯Ø± Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡: {e}")

@client.on(events.NewMessage(pattern='/start'))
async def start(event):
    if event.sender_id not in ALLOWED_USERS:
        await event.reply("Ø±Ø¨Ø§Øª Ø®ØµÙˆØµÛŒ Ø§Ø³Øª â€” Ø¯Ø³ØªØ±Ø³ÛŒ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ØµØ§Ø­Ø¨ Ùˆ ÛŒÚ© Ù†ÙØ± Ø¯ÛŒÚ¯Ø±")
        return
    
    start_text = (
        "ğŸ¤– Ø®Ø¯Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ± Ø´Ø®ØµÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯!\n\n"
        "Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡:\n"
        "â€¢ @username Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯\n"
        "â€¢ ÛŒØ§ Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯\n\n"
        "âš ï¸ Ù†Ú©ØªÙ‡: Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„ Ø¹Ù…ÙˆÙ…ÛŒ ÙØ¹Ø§Ù„ÛŒØª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "/save @user â†’ Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø±Ø§ÛŒ Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡\n"
        "/watch @user â†’ Ù‡Ø´Ø¯Ø§Ø± Ú©Ø§Ù…Ù„\n"
        "/panel â†’ Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª"
    )
    await event.reply(start_text)

@client.on(events.NewMessage(pattern='/save'))
async def save_user(event):
    if event.sender_id not in ALLOWED_USERS:
        return
    try:
        if len(event.message.text.split()) < 2:
            error_text = (
                "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… ÛŒØ§ Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯\n"
                "Ù…Ø«Ø§Ù„: /save @username ÛŒØ§ /save 123456789"
            )
            await event.reply(error_text)
            return
            
        user_input = event.message.text.split(maxsplit=1)[1].strip()
        user = await get_user_by_input(user_input)
        
        saved_users[user.id] = {
            'name': user.username or user.first_name or str(user.id), 
            'chat_id': event.chat_id
        }
        username_info = await get_user_info(user.id)
        await event.reply(f"âœ… Ú©Ø§Ø±Ø¨Ø± @{username_info} Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯\nğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ Ù‡Ø± Ø±ÙˆØ² Û¸ ØµØ¨Ø­ Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯")
        
    except Exception as e:
        error_text = (
            f"âŒ Ø®Ø·Ø§: {str(e)}\n\n"
            "ğŸ’¡ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ:\n"
            "â€¢ Ø§Ø² @username Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯\n"
            "â€¢ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø³Øª\n"
            "â€¢ Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯"
        )
        await event.reply(error_text)

@client.on(events.NewMessage(pattern='/watch'))
async def watch_user(event):
    if event.sender_id not in ALLOWED_USERS:
        return
    try:
        if len(event.message.text.split()) < 2:
            error_text = (
                "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… ÛŒØ§ Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯\n"
                "Ù…Ø«Ø§Ù„: /watch @username ÛŒØ§ /watch 123456789"
            )
            await event.reply(error_text)
            return
            
        user_input = event.message.text.split(maxsplit=1)[1].strip()
        user = await get_user_by_input(user_input)
        
        watching_alert.add(user.id)
        watching_online.add(user.id)
        username_info = await get_user_info(user.id)
        await event.reply(f"ğŸ‘ï¸ Ù‡Ø´Ø¯Ø§Ø± Ú©Ø§Ù…Ù„ ÙØ¹Ø§Ù„ Ø´Ø¯ Ø¨Ø±Ø§ÛŒ @{username_info}")
        
    except Exception as e:
        error_text = (
            f"âŒ Ø®Ø·Ø§: {str(e)}\n\n"
            "ğŸ’¡ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ:\n"
            "â€¢ Ø§Ø² @username Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯\n"
            "â€¢ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø³Øª"
        )
        await event.reply(error_text)

@client.on(events.NewMessage)
async def normal_search(event):
    if event.sender_id not in ALLOWED_USERS or not event.is_private or event.message.text.startswith('/'):
        return
    
    user_input = event.message.text.strip()
    try:
        user = await get_user_by_input(user_input)
    except Exception as e:
        await event.reply(f"âŒ {str(e)}")
        return

    msg = await event.reply("ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬ÙˆÛŒ ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±...")
    
    try:
        today_msgs = await search_today(user.id)
        week_msgs = await search_7days(user.id)

        if not today_msgs:
            await msg.edit(f"ğŸ“­ Ú©Ø§Ø±Ø¨Ø± @{user.username or user.id} Ø§Ù…Ø±ÙˆØ² Ù‡ÛŒÚ† ÙØ¹Ø§Ù„ÛŒØªÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ Ù†Ø¯Ø§Ø´ØªÙ‡")
            return

        first = min(today_msgs, key=lambda x: x.date)
        last = max(today_msgs, key=lambda x: x.date)

        # Ú†Ø§Ø±Øª Ø³Ø§Ø¹ØªÛŒ
        hours = {i: 0 for i in range(24)}
        for m in today_msgs:
            hours[m.date.hour] += 1
        max_h = max(hours.values()) or 1
        hour_chart = "ğŸ“Š ÙØ¹Ø§Ù„ÛŒØª Ø³Ø§Ø¹ØªÛŒ:\n"
        for h in range(24):
            if hours[h] > 0:
                bar = "â–ˆ" * int(hours[h] * 10 / max_h)
                hour_chart += f"{h:02d}:00 {bar} {hours[h]}\n"

        text = f"ğŸ“‹ Ú¯Ø²Ø§Ø±Ø´ @{user.username or user.id}\n\n"
        text += f"ğŸ“… Ø§Ù…Ø±ÙˆØ²: {len(today_msgs)} Ù¾ÛŒØ§Ù…\n"
        text += f"â° Ø§ÙˆÙ„ÛŒÙ†: {first.date.strftime('%H:%M')}\n"
        text += f"â° Ø¢Ø®Ø±ÛŒÙ†: {last.date.strftime('%H:%M')}\n"
        text += f"ğŸ“† Û· Ø±ÙˆØ² Ú¯Ø°Ø´ØªÙ‡: {len(week_msgs)} Ù¾ÛŒØ§Ù…\n\n"
        text += hour_chart

        buttons = [
            [KeyboardButtonCallback("ğŸ“¦ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù…Ø¯ÛŒØ§Ù‡Ø§", data=f"zip_{user.id}".encode())],
            [KeyboardButtonCallback("ğŸ‘¥ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§", data=f"chats_{user.id}".encode())]
        ]
        await msg.edit(text, buttons=buttons)
        
    except Exception as e:
        await msg.edit(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬Ùˆ: {str(e)}")

@client.on(events.CallbackQuery(pattern=lambda data: data.startswith(b"zip_")))
async def zip_handler(event):
    uid = int(event.data.split(b"_")[1])
    await event.answer("ğŸ“¦ Ø¯Ø± Ø­Ø§Ù„ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ù…Ø¯ÛŒØ§Ù‡Ø§...", alert=True)
    
    try:
        msgs = await search_today(uid)
        media_msgs = [m for m in msgs if m.media]
        
        if not media_msgs:
            return await event.answer("âŒ Ù…Ø¯ÛŒØ§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯")
        
        await event.reply(f"ğŸ” {len(media_msgs)} Ù…Ø¯ÛŒØ§ Ù¾ÛŒØ¯Ø§ Ø´Ø¯. Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ...")
        
        # Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overload
        media_msgs = media_msgs[:15]
        
        zip_buffer = BytesIO()
        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for i, m in enumerate(media_msgs):
                try:
                    file_data = await client.download_media(m.media, bytes)
                    if file_data:
                        if m.photo:
                            ext = ".jpg"
                        elif m.video:
                            ext = ".mp4"
                        elif m.audio:
                            ext = ".mp3"
                        else:
                            ext = ".dat"
                        
                        zf.writestr(f"media_{i+1}{ext}", file_data)
                except Exception as e:
                    print(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¯ÛŒØ§: {e}")
        
        zip_buffer.seek(0)
        username_info = await get_user_info(uid)
        
        await client.send_file(
            event.sender_id, 
            zip_buffer, 
            filename=f"Ù…Ø¯ÛŒØ§Ù‡Ø§ÛŒ_{username_info}_{datetime.now().strftime('%Y%m%d')}.zip",
            caption=f"ğŸ“¦ Ù…Ø¯ÛŒØ§Ù‡Ø§ÛŒ Ø§Ù…Ø±ÙˆØ² Ú©Ø§Ø±Ø¨Ø± @{username_info}"
        )
        await event.answer("âœ… ÙØ§ÛŒÙ„ ZIP Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!")
        
    except Exception as e:
        await event.answer(f"âŒ Ø®Ø·Ø§: {str(e)}")

@client.on(events.CallbackQuery(pattern=lambda data: data.startswith(b"chats_")))
async def show_chats(event):
    uid = int(event.data.split(b"_")[1])
    msgs = await search_today(uid)
    chats = {}
    for m in msgs:
        chat = m.chat
        if not chat:
            continue
        cid = chat.id
        title = getattr(chat, 'title', 'Ú©Ø§Ù…Ù†Øª Ú©Ø§Ù†Ø§Ù„')
        prefix = "ğŸ’¬ Ú©Ø§Ù…Ù†Øª" if getattr(chat, 'broadcast', False) and m.is_reply else "ğŸ‘¥ Ú¯Ø±ÙˆÙ‡"
        key = f"{prefix}_{cid}"
        if key not in chats:
            chats[key] = {'title': title, 'msgs': [], 'prefix': prefix}
        chats[key]['msgs'].append(m)

    text = f"ğŸ“ Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„ Ø§Ù…Ø±ÙˆØ² ({len(chats)})\n\n"
    buttons = []
    for key, data in list(chats.items())[:10]:
        count = len(data['msgs'])
        btn_text = f"{data['prefix']}: {data['title'][:25]} ({count})"
        cid = key.split("_", 1)[1]
        buttons.append([KeyboardButtonCallback(btn_text, data=f"show_{uid}_{cid}".encode())])
    
    buttons.append([KeyboardButtonCallback("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", data=b"back_main")])
    await event.edit(text, buttons=buttons)

@client.on(events.NewMessage(pattern='/panel'))
async def panel(event):
    if event.sender_id != ADMIN_ID:
        await event.reply("âŒ ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ø§ØµÙ„ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø±Ø¯")
        return
    
    text = f"ğŸ› Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø¯Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ±\n\n"
    text += f"ğŸ“¡ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù„Ø§ÛŒÙˆ: {len(live_targets)}\n"
    text += f"ğŸ‘ï¸ Ù‡Ø´Ø¯Ø§Ø± Ú©Ø§Ù…Ù„: {len(watching_alert)}\n"
    text += f"ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡: {len(saved_users)}\n\n"
    
    buttons = [[KeyboardButtonCallback("ğŸ›‘ ØªÙˆÙ‚Ù Ù‡Ù…Ù‡", data=b"stop_all")]]
    await event.reply(text, buttons=buttons)

@client.on(events.CallbackQuery(pattern=b"stop_all"))
async def stop_all_handler(event):
    if event.sender_id != ADMIN_ID:
        await event.answer("âŒ Ø¯Ø³ØªØ±Ø³ÛŒ denied", alert=True)
        return
    
    live_targets.clear()
    watching_alert.clear()
    watching_online.clear()
    saved_users.clear()
    last_profile.clear()
    await event.edit("âœ… Ù‡Ù…Ù‡ Ú†ÛŒØ² Ù…ØªÙˆÙ‚Ù Ùˆ Ù¾Ø§Ú© Ø´Ø¯")

@client.on(events.CallbackQuery(pattern=b"back_main"))
async def back_main_handler(event):
    await event.edit("ğŸ”™ Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒØ¯")

@client.on(events.CallbackQuery(pattern=b"back_chats"))
async def back_chats_handler(event):
    await event.edit("ğŸ”™ Ø¨Ù‡ Ù„ÛŒØ³Øª Ú†Øªâ€ŒÙ‡Ø§ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒØ¯")

async def main():
    try:
        print("âœ… Ø®Ø¯Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ± Ø´Ø®ØµÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯!")
        print("ğŸ¤– Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§Ø³Øª...")
        await client.run_until_disconnected()
    except Exception as e:
        print(f"Ø®Ø·Ø§ÛŒ Ø§ØµÙ„ÛŒ: {e}")

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    except KeyboardInterrupt:
        print("Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
    finally:
        loop.close()
